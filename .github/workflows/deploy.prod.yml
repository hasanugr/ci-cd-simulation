name: Deploy to PROD

# Dynamic name for better visibility
run-name: Deploy PROD by @${{ github.actor }}

# Manual trigger only, no inputs required
on:
  workflow_dispatch:

jobs:
  deploy:
    runs-on: self-hosted
    
    # PROD Environment tracking for deployment history and status
    environment:
      name: PROD
      url: http://localhost:8081/  # Local PROD for testing - OPTIONAL: Uncomment and set your live PROD site URL for direct access
      # url: http://your-prod-site.com  # OPTIONAL: Uncomment and set your live PROD site URL for direct access
    
    # Write permission required to push merge and tags back to GitHub
    permissions:
      contents: write

    steps:
      - name: Checkout MAIN Branch
        uses: actions/checkout@v4
        with:
          ref: main           # Always target MAIN branch explicitly (Production)
          fetch-depth: 0      # Fetch full history for tag reading and merge operation

      - name: Setup Git User (For Merge)
        run: |
          git config --global user.name "CI/CD Bot"
          git config --global user.email "bot@ci-cd.com"

      # --- STEP 1: READ VERSION FROM QA TAG ---
      - name: Get Version from QA
        shell: powershell
        run: |
          # Fetch all tags and QA branch from remote
          git fetch origin qa --tags
          
          # Get all QA tags sorted by version
          $allQaTags = git tag -l "qa-v*" | Sort-Object -Descending
          
          if ($allQaTags.Count -eq 0) {
            $err = "No QA tag found. Please deploy to QA environment first."
            Write-Host "[!] $err" -ForegroundColor Red
            echo "FAILURE_REASON=$err" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
            exit 1
          }
          
          # Get the latest QA tag (first in sorted list)
          $qaTag = $allQaTags[0]
          
          Write-Host ">> Latest QA Tag: $qaTag" -ForegroundColor Cyan
          
          # Convert qa-v0.1.0.1 to prod-v0.1.0.1
          $prodTag = $qaTag -replace "^qa-", "prod-"
          
          # Extract app version (remove qa-v prefix and last build number)
          # Example: qa-v0.1.0.1 -> 0.1.0
          $appVer = $qaTag -replace "^qa-v", "" -replace "\.\d+$", ""
          
          Write-Host ">> Target PROD Tag: $prodTag" -ForegroundColor Green
          Write-Host ">> App Version: $appVer" -ForegroundColor Green
          
          # Save to environment for next steps
          echo "FULL_VERSION=$prodTag" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          echo "APP_VERSION=$appVer" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          echo "QA_TAG=$qaTag" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append

      # --- STEP 2: MERGE ---
      - name: Merge QA into MAIN
        shell: powershell
        run: |
          Write-Host ">> Merging QA into MAIN..."
          git fetch origin qa
          
          # Try to merge QA into MAIN
          # Added --no-edit to prevent git from waiting for a commit message editor
          $commitMsg = "chore(prod): release qa to main [v$env:APP_VERSION from $env:QA_TAG] - CI/CD Auto-Release"
          git merge origin/qa --allow-unrelated-histories --no-edit -m "$commitMsg"
          
          # Check if merge resulted in conflicts
          $conflictFiles = git diff --name-only --diff-filter=U
          if ($conflictFiles) {
            $err = "Merge conflict detected. Conflicting files: $conflictFiles"
            Write-Host "[!] MERGE CONFLICT DETECTED!" -ForegroundColor Red
            Write-Host "Conflicting files:" -ForegroundColor Yellow
            Write-Host $conflictFiles
            Write-Host "`nPlease resolve conflicts manually and try again." -ForegroundColor Yellow
            echo "FAILURE_REASON=$err" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
            exit 1
          }
          
          # Push merged changes back to GitHub
          git push origin main
          Write-Host "[OK] Merge Success and Pushed (QA -> MAIN)!"

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '24'

      # --- STEP 3: DEPLOY ---
      # Install & Build is handled inside the deploy script on the server
      - name: Run Deploy Script
        shell: powershell
        run: |
          # MAIN branch is now updated, triggering deployment...
          ./scripts/deploy.ps1 -environment "PROD"
          if ($LASTEXITCODE -ne 0) {
            $err = "Deploy script failed with exit code $LASTEXITCODE. Check deployment logs."
            echo "FAILURE_REASON=$err" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
            exit 1
          }

      # --- STEP 4: TAGGING (Inherited from QA) ---
      # Only create tag if deployment was successful
      - name: Create Git Tag
        if: success()
        shell: powershell
        run: |
          # Check if tag already exists
          $existingTag = git tag -l $env:FULL_VERSION
          if ($existingTag) {
            Write-Host "[!] Tag $env:FULL_VERSION already exists. Deployment succeeded but tag was already created." -ForegroundColor Yellow
            exit 0
          } else {
            git tag $env:FULL_VERSION
            git push origin $env:FULL_VERSION
            Write-Host "[OK] Tag Created and Pushed: $env:FULL_VERSION" -ForegroundColor Green
          }

      # --- STEP 5: UPDATE DEPLOYMENT DESCRIPTION ---
      # Set custom deployment description for GitHub Environments UI
      - name: Update Deployment Description
        if: success()
        uses: actions/github-script@v7
        with:
          script: |
            const fullVersion = process.env.FULL_VERSION;
            const qaTag = process.env.QA_TAG;
            
            // Get current deployment
            const deployments = await github.rest.repos.listDeployments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              environment: 'PROD',
              per_page: 1
            });
            
            if (deployments.data.length > 0) {
              const deploymentId = deployments.data[0].id;
              
              // Update deployment with custom description
              await github.rest.repos.updateDeployment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                deployment_id: deploymentId,
                description: `ðŸš€ Deploy PROD ${fullVersion} from ${qaTag}`
              });
              
              console.log(`Updated deployment description: Deploy PROD ${fullVersion}`);
            }

      # --- STEP 6: SUMMARY ---
      # Always show summary, even if deployment failed
      - name: Add Job Summary
        if: always()
        shell: powershell
        run: |
          $status = if ("${{ job.status }}" -eq "success") { "SUCCESS" } else { "FAILED" }
          
          $msg = "### Deploy Summary`n"
          $msg += "* **Status:** $status`n"
          
          # Show error reason if failed
          if ($env:FAILURE_REASON) {
            $msg += "* **ERROR REASON:** $env:FAILURE_REASON`n"
          }
          
          $msg += "* **Environment:** PROD`n"
          $msg += "* **Source QA Tag:** $($env:QA_TAG -replace '^$', 'N/A')`n"
          $msg += "* **PROD Release Tag:** $($env:FULL_VERSION -replace '^$', 'N/A - Failed before tagging')`n"
          $msg += "* **App Version:** $($env:APP_VERSION -replace '^$', 'N/A')`n"
          $msg += "* **Time:** $(Get-Date -Format 'yyyy-MM-dd HH:mm')`n"
          
          echo $msg | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append